## MySQL 日志

### undo log

> 是 InnoDB 存储引擎层生成的日志，实现了事务中的**原子性**，主要用于**事务回滚的MVCC**

#### 为什么需要 undo log？

在执行一条 增删改 语句时，虽然没有显式开启事务和提交事务，但是MySQL **隐式开启事务**来执行增删改，执行完就自动提交事务，这样保证了执行完增删改后，立刻就可以在数据库看到结果

如果每次在事务执行过程中，都记录下回滚时需要的信息到一个日志里，那么在事务执行中途发生了MySQL崩溃后，就不用担心无法回滚到事务之前的数据

undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚

---

每当 InnoDB 引擎对一条记录进行 修改时，要把回滚需要的信息记录到 undo log里

**插入一条记录，要把这条记录的主键值记下，回滚只需删掉这个主键值对应的记录就行**

**删除一条记录，要把这条记录的内容都记下来，回滚时把这些内容组成的记录，插入就可以了**

**修改一条记录，把被更新列的旧值记下来，回滚把这些列更新为旧值就可以了 **

一条记录的每一次更新操作产生的 undo log 格式都有一个 `roll_pointer` 和一个`trx_id`事务id

* 通过`trx_id`可以知道该记录是被哪个事务修改的
* 通过`roll_pointer`可以将这些 undo log串成一个链表，就称为版本链

**undo log的另一个作用就是通过 ReadView + undo log 实现 MVCC(多版本并发控制)**



### redo log

> 重做日志是 InnoDB 存储引擎层生成的日志，实现了事务的**持久性**，主要用于**掉电等故障恢复**

#### 为什么需要 redo log？

为了防止断电导致数据丢失的问题，当一条记录要更新时，InnoDB 引擎就先更新内存(同时标记该数据页为脏页)，然后将本次对这个页的修改以 redo log形式记录下来，更新就算完成了。

后续，InnoDB 引擎会**在适当的时候**，由后台线程将缓存在 Buffer Pool的脏页刷新到磁盘中，这就是 WAL(Write-Ahead Logging)技术



#### 什么是适当的时候刷新到磁盘中？

InnoDB 为 redo log 的刷盘策略提供了`innodb_flush_log_at_trx_commit`参数，支持三种策略

* 0，设置为0，**表示每次事务提交时不进行刷盘操作**
* 1，设置为1，**表示每次事务提交都进行刷盘操作（默认值）**
* 2，设置为2，**表示每次事务提交时都只把 redo log buffer内容写到 page cache**



#### redo log 与 undo log 的区别

* redo log 记录此次事务**完成后**的数据状态，记录的是更新后的值
* undo log记录此次事务**开始前**的数据状态，记录的是更新前的值

### binlog

> 归档日志：是Server层生成的日志，主要用于数据备份和主从复制

前面说的 undo log 和 redo log 这两个日志都是 InnoDB 存储引擎生成的

MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事务执行过程中产生的所有 binlog 统一写入 binlog 文件

binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 select 和 show

#### bin log什么时候刷盘？

事务过程中，先把日志写到 binlog cache，事务提交时候，再把 binlog cache 写到 binlog 文件中



#### redo log 和 binlog 有什么区别？

1 、适用对象不同

* binlog 是 MySQL 的Server 层实现的日志，所有存储引擎都可以使用
* redo log 是 InnoDB 存储引擎实现的日志

2、文件格式不同

* binlog 有 3种格式：STATEMENT(默认)、ROW、MIXED
  * STATEMENT：每一条修改数据的 SQL 都会被记录，但 STATEMENT 有动态函数的问题，比如用了 now函数，主库执行的结果和从库不一样
  * ROW：记录行数据最终被改成什么样了，不会出现STATEMENT动态函数的问题
  * MIXED： 包含了 STATEMENT 和 ROW 模式，会根据不同情况自动使用以上两个模式
* redo log 是物理日志

3、写入方式不同

* binlog 是追加写，写满一个文件，创建一个新文件继续写，不会覆盖以前的日志
* redo log 是循环写，日志空间大小固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志

4、用途不同

* binlog 用于备份恢复、主从复制
* redo log 用于掉电等故障修复

**因为bin log是追加写的方式，保存的全量日志可以用于恢复，redo log循环写，会覆盖，不能用于恢复数据**

### 主从复制

MySQL 主从复制依赖于 binlog，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上，复制的过程就是把 binlog 中的数据从主库传输到从库上。这个过程一般是**异步的**，主库执行事务操作的线程不会等待复制 binlog 的线程同步完成

### 两阶段提交

redo log 让 InnoDB存储引擎有了崩溃恢复能力

bin log保证 MySQL集群架构的数据一致性

在执行更新语句过程，会记录`redo log` 与`bin log`两块日志，以基本的事务为单位，`redo log`在事务执行过程中可以不断写入，而`binlog`只有在提交事务时才写入，所以 redo log 与 binlog写入时间不一样。两块独立的逻辑，可能会出现半成功的状态，就会造成两份日志间逻辑不一致

* 如果在将 redo log刷入到磁盘后，MySQL突然宕机了，而 binlog还没来得及写入
* 如果在将 binlog刷入到磁盘后，MySQL突然宕机了，而redo log 还没来得及写入

**如果出现半成功的状态都会造成主从环境的数据不一致**

MySQL为了避免两份日志间的逻辑不一致问题，使用了**两阶段提交**来解决

两阶段提交把单个事务的提交拆分成两个阶段，**准备阶段和提交阶段**

* 准备阶段：写入 redo log，将redo log对应的事务状态设置成prepare，然后将redo log 刷新到磁盘
* 提交阶段：写入binlog，然后将binlog刷新到磁盘，接着调用引擎的提交事务接口，将 redo log状态设置为commit

不管是**已经写入redo log，还没写入binlog**。还是**已经写入redo log和binlog，还没写入commit标识崩溃了，**此时的redo log都处于 prepare状态

**如果 redo log 设置 commit阶段发生异常，并不会回滚事务**

#### 两阶段提交的问题

虽然保证了redo log 和 binlog 的数据一致性，但性能很差

* 磁盘IO次数高
* 锁竞争激烈