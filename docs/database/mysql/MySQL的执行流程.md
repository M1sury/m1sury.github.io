## MySQL 的执行流程

![未命名文件](https://my-lottery.oss-cn-shanghai.aliyuncs.com/lottery/未命名文件.png)

从上图可以看到，MySQL 的架构共分为两层：**Server层和存储引擎层**

* **Server 层负责建立连接，分析和执行SQL。**MySQL 大多数的核心功能模块都在 Server 层，主要包括连接器、查询缓存、解析器、预处理器、优化器、执行器等。并且，**所有的内置函数(如日期、时间，数学等函数) 和所有跨存储引擎的功能(如存储过程、触发器和视图等) 都在Server 层实现**
* **存储引擎层负责数据的存储和提取。**支持 InnoDB、MyISAM、Memory等多个存储引擎，不同的存储引擎共用一个 Server 层，**从 MySQL5.5 版本开始，默认的存储引擎就是 InnoDB**

### 连接器

在刚开始使用 MySQL 的时候，一定会写下的第一条命令，**连接MySQL服务**，才能执行 SQL 语句

```sh
# -h 执行MySQL服务的IP地址
# -u 指定用户名
# -p 指定密码
mysql -h(ip) -u(user) -p(password)
```

连接的过程需要先经过 TCP 三次握手，因为 MySQL 是基于 TCP 协议进行传输的，如果 MySQL 服务没有启动

会收到以下报错：

```sh
Can 't connect to local MySQL server through socket....
```

如果 MySQL 服务正常运行，完成 TCP 服务的建立后，连接器就要开始验证你的用户名和密码，用户名或密码不对，会收到`Access denied for user`的错误，然后客户端结束执行

如果用户名和密码没错，连接器会获取到该用户的权限保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑判断

就是说，如果一个用户已经建立了连接，既然管理员中途修改了该用户的权限，也不会影响已经存在连接权限。修改后，只有再次新建的连接才会使用新的权限进行逻辑判断

> 怎么查询 MySQL 服务被多少个客户端连接？

可以执行 `show processlist` 命令进行查看

> MySQL 的连接数有限制么？

MySQL 服务支持的最大连接数由 `max_connections` 参数控制

MySQL 的连接和 HTTP 一样，有短连接和长连接：

短连接执行一次 SQL ，断开连接

长连接执行多条 SQL，断开连接

使用长连接的好处就是可以减少建立连接和断开连接的过程。同样也是双刃剑，使用长连接后可能会占用内存增多，MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在断开连接才会释放。**如果长连接累计很多，会导致 MySQL 服务占用内存太大，可能会被系统强制杀掉，会发生 MySQL 服务异常重启的现象**

> 如果解决这个问题？

* **定期断开长连接**，会有一个最大的连接时间，如果超过这个时间，服务端就会断开这个长连接
* **客户端主动重置连接**，MySQL5.7已经实现了`mysql_reset_connection()`函数的接口，这是接口函数，当客户端执行了一个很大的操作后，在代码中调用`mysql_reset_connection()`函数会重置连接，达到释放内存的效果，并且这个过程不需要重连和重新权限认证



### 查询缓存

连接器工作完成后，客户端可以向 MySQL 服务发送 SQL 语句了，MySQL 服务收到 SQL 语句后，会解析出 SQL 语句的第一个字段，判断是什么类型的语句

如果是 查询语句，MySQL 会先去查询缓存里查找缓存数据，相当于一个`HashMap<查询语句,SQL语句查询的结果>`。

如果命中查询缓存，就直接返回结果，没有命中就要继续向下执行，执行结束，会把查询的结果存入缓存中

**由于对于某些更新频繁的表，查询缓存命中率很低，只要一个表有更新，这个表的查询缓存就会清空。所以 MySQL 8.0删除了查询缓存**

如果 MySQL 8.0前的版本，想要关闭查询缓存，可以将参数 `query_cache_type` 设置成 `DEMAND`



### 解析器

在正式执行 SQL 查询语句之前，MySQL 会先对 SQL 语句做解析

* **词法分析**：MySQL 会根据你输入的字符串识别出关键字出来，构建出 SQL 语法树，这个方便后面模块获取 SQL 类型、表名、字段名、where条件等
* **语法分析**：根据词法分析的结果，语法解析器会根据语法规则，判断输入的SQL 语句是否满足 MySQL 语法

如果输入的 SQL 语法不对，就会在解析器阶段报错，**如果表不存在或者字段不存在，并不是在解析器里做的，而是在预处理阶段**

### 执行SQL

> 进入执行 SQL 查询语句的流程，每条 `SELECT` 查询语句都要注意可分为下面三阶段：
>
> * prepare 阶段(预处理)
> * optimize 阶段(优化)
> * execute 阶段(执行)

#### 预处理器

预处理器要做的事情

* 检查 SQL 查询语句的表或字段是否存在
* 将 `select *` 中的`*`符合，扩展为表上的所有列

#### 优化器

经过预处理阶段，还需要为 SQL 查询语句制定一个执行计划

**优化器主要负责将 SQL 查询语句的执行方案确定下来**，在表内有多个索引的时候，优化器会基于查询成本考虑，决定选择使用哪个索引

要想知道优化器选择了哪个索引，可以在查询语句前增加 `explain` 关键词，就会输出这条查询语句的执行计划，执行计划中的 key 字段表示执行过程中使用哪个索引，下面的key 为 `PRIMARY` 使用了主键索引

![image-20221013094247186](https://my-lottery.oss-cn-shanghai.aliyuncs.com/lottery/image-20221013094247186.png)

如果查询语句的执行计划 key 为 null 说明没有使用索引，会全表扫描，这种方式是效率最低的

#### 执行器

经过了优化器后，确定了最终的执行方案，MySQL才开始真正的执行语句。**在执行过程中，执行器会和存储引擎交互，交互是以记录为单位的**

**主键索引查询**

```sql
select * from compression_code where id = 1
```

这条语句的查询条件用到了主键索引，并且是等值查询，同时主键 id 是唯一的，不会有id相同的记录，所以优化器选用访问类型为 `const`进行查询，执行器和存储引擎的执行流程：

* 执行器第一次查询，会调用`read_first_record`函数指针指向的函数，因为优化器选择访问类型是`const`，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件给了存储引擎，让存储引擎定位符合条件的第一条记录
* 存储引擎通过主键索引的 B+树结构定位到 id =1 的第一条记录，如果记录不存在，会向执行器返回找不到记录的错误，结束查询。如果记录存在，就会将记录返回给执行器
* **执行器查询的过程是一个 while 循环**，所以还会再查一次，但是这次不是第一次查询，所以调用 `read_record`函数指针指向的函数，优化器选择的访问类型是`const`，这个函数指针被指向一个永远返回 -1 的函数，执行器就退出循环，结束查询