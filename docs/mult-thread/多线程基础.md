## 并发编程的基础概念

### 什么是多线程并发编程？

> 首先要澄清**并发**和**并行**的概念
>
> 在单 CPU 的时代多个任务都是并发执行的
>
> * 并发：前提是**单CPU**，一个CPU同时只能执行一个任务，并发是通过线程的上下文切换，实现多个任务交替执行。由于速度较快，所以看似是在一起执行，实际上是在并发执行
> * 并行：是指**多个CPU**同时执行多个任务

在多线程编程实践中，线程的个数往往多余 CPU的个数，所以一般都称为**多线程并发编程**而不是多线程并行编程

### 为什么要进行多线程并发编程？

多核 CPU 时代的到来打破了 单核 CPU 对多线程性能的限制。多个 CPU 意味着每个线程可以使用自己的 CPU 运行，减少了**线程上下文切换的开销**，但是随着对应用系统性能和吞吐量要求的提高，有了处理海量数据和请求的要求，都对高并发编程有迫切的需求



### Java 中的线程安全问题

 说到线程安全，要先明白什么是共享资源，共享资源就是该资源被多个线程所持有或者多个线程都可以去访问的资源

**线程安全问题**是指多个线程同时读写一个共享资源并且没有任何同步措施时，导致出现脏数据或者其他不正确的结果的问题

![image-20220923172130601](https://my-lottery.oss-cn-shanghai.aliyuncs.com/lottery/image-20220923172130601.png)

上图中，线程 A 和线程 B 可以同时操作主内存中的共享变量。

如果只是多个线程去读取共享资源不做修改，不会出现线程安全问题，**只有当至少一个线程修改共享资源时才会存在线程安全问题**

开启多个线程对共享资源进行累加

```java
public static Integer num = 0;

    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < 100; i++) {
            new Thread(()->{
                num++;
                System.out.println(num);
            }).start();
        }
        System.out.println(num);
    }
```

### Java 中共享变量的内存可见性问题

说到内存可见性，下图是多线程下处理共享变量时 Java 的内存模型

![image-20220923173249734](https://my-lottery.oss-cn-shanghai.aliyuncs.com/lottery/image-20220923173249734.png)

**Java 内存模型规定，将所有的变量存放在主内存中，当线程使用变量时，会把主内存的变量复制到自己的工作内存中，线程读写变量时操作的是自己的工作内存中的变量**

![image-20220923173911454](https://my-lottery.oss-cn-shanghai.aliyuncs.com/lottery/image-20220923173911454.png)

图中所示的是一个双核 CPU 系统架构，**在有些架构里面会有一个所有CPU共享的三级缓存**。**在 Java 内存模型里面的工作内存，就对应这里的 L1 或者 L2 或者 CPU的寄存器**

当一个线程操作共享变量时，首先从主内存复制共享变量到自己的工作内存，然后对工作内存变量进行处理，处理完将变量值更新到主内存

假如线程 A和线程 B 同时处理一个共享变量，假设A 和 B 使用不同 CPU执行，并且两级 Cache 都为空

* 线程 A 首先获取共享变量 X 的值，由于两级 Cache 都没有命中，所以加载主内存中 X 的值，假如为0。然后把 X=0 的值缓存到二级缓存，线程A 修改 X 的值为1，然后将其写入二级缓存，并且刷新到主内存。这个操作结束后，线程 A 所在CPU的两级 Cache和主内存的 X 的 值都是1
* 线程 B 获取 X 的值，首先一级缓存没有命中，看二级缓存(**现在一般都是三级缓存**)，二级缓存命中了，所以返回 X=1。然后线程 B 修改 X 的值为2，将其存放在线程 B 所在的一级 Cache 和共享 二级 Cache 中，最后更新主内存中的 X 的值为2。目前看来，一切正常
* 线程 A 又需要修改 X 的值，获取一级缓存命中，并且 X=1，问题是**线程B已经把 X 的值修改为2，线程 A 获取的还是1**，这就是**共享变量的内存不可见问题**，也就是线程 B 写入的值对线程 A 不可见

**如何解决？使用 Java中的 synchronized 关键字解决**

## 解决方案

### Synchronized 关键字

> synchronized 是 Java 提供的一种原子性内置锁，Java的每个对象都可以把它当作一个同步锁使用

线程的执行代码在进入 synchronized 代码块前会自动获取锁，这时其他线程访问该同步代码块就会被阻塞挂起。

拿到锁的线程会在正常退出同步代码块或者抛出异常后或者在同步块内调用该锁的 wait方法释放锁，synchronized 是排他锁，当一个线程获取到这个锁之后，其他线程必须等待该线程释放后才能获取该锁

**由于 Java 中的线程与 OS 的原生线程一一对应，所以当阻塞一个线程时，需要从用户态切换到内核态执行阻塞操作，这是很耗时的操作，synchronized 的使用会导致上下文切换**

#### synchronized 的内存语义

synchronized 的内存语义，是**把在 synchronized 块内使用到的变量从线程的工作内存中清除，这样在 synchronized块内使用到该变量不会从线程的工作内存中获取，而是直接从主内存中获取**。退出 synchronized 块的内存语义是把在 synchronized 块对共享变量的修改刷新到主内存

当获取锁后清空锁块内本地内存将要使用到的共享变量，在使用这边共享变量时从主内存中加载，释放锁之后把本地内存中修改的共享变量刷新到主内存

**synchronized 除了可以解决共享变量内存可见性问题，还经常被用来实现原子性操作，synchronized 关键字会引起线程上下文切换并带来线程调度开销**

###  volatile 关键字